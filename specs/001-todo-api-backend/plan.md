# Implementation Plan: Todo Full-Stack Web Application ‚Äî Backend & API

**Branch**: `001-todo-api-backend` | **Date**: 2026-01-23 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/001-todo-api-backend/spec.md`

## Summary

Design and implement a secure, scalable FastAPI backend that exposes RESTful APIs for a multi-user Todo application with strict user isolation, JWT-based authentication, and persistent storage using Neon Serverless PostgreSQL.

**Core Requirements**:
- 6 RESTful API endpoints for task CRUD operations
- JWT token verification on every request
- User data isolation (users only access their own tasks)
- SQLModel ORM integration with Neon PostgreSQL
- Pydantic request/response validation
- Comprehensive error handling (401, 403, 404, 422, 500, 503)

**Technical Approach**:
- FastAPI framework with async/await for high performance
- SQLModel for type-safe ORM with Pydantic integration
- JWT verification using python-jose library
- Dependency injection for authentication
- Async SQLAlchemy engine with connection pooling
- OpenAPI documentation auto-generated by FastAPI

## Technical Context

**Language/Version**: Python 3.12
**Primary Dependencies**: FastAPI 0.109.0, SQLModel 0.0.14, python-jose 3.3.0, asyncpg 0.29.0
**Storage**: Neon Serverless PostgreSQL (via SQLModel async engine)
**Testing**: pytest with pytest-asyncio for async testing
**Target Platform**: Linux server (uvicorn ASGI server)
**Project Type**: Web (backend API only)
**Performance Goals**: <500ms API response time (p95), 100+ concurrent requests/second
**Constraints**: Stateless operation (no session storage), serverless-optimized connection pooling
**Scale/Scope**: Multi-user application, 6 API endpoints, single Task entity, JWT-based auth

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Security Principle

‚úÖ **PASS**: All API endpoints require JWT authentication via `Authorization: Bearer <token>` header
‚úÖ **PASS**: Unauthorized requests return HTTP 401 status code
‚úÖ **PASS**: User data is isolated - queries filtered by authenticated user_id
‚úÖ **PASS**: JWT shared secret stored in `BETTER_AUTH_SECRET` environment variable
‚úÖ **PASS**: JWT verification prevents cross-user data access (403 Forbidden)

### Accuracy Principle

‚úÖ **PASS**: REST API returns standard HTTP status codes (200, 201, 204, 401, 403, 404, 422, 500, 503)
‚úÖ **PASS**: API responses validated via Pydantic schemas
‚úÖ **PASS**: Database queries enforce user isolation (WHERE owner_id = authenticated_user_id)
‚úÖ **PASS**: CRUD operations produce predictable, consistent results

### Clarity Principle

‚úÖ **PASS**: API contracts documented via OpenAPI/Swagger (auto-generated by FastAPI)
‚úÖ **PASS**: Request/response schemas defined with Pydantic models
‚úÖ **PASS**: Error messages return structured detail field
‚úÖ **PASS**: Implementation traceable to specification (FR-001 through FR-025)

### Reproducibility Principle

‚úÖ **PASS**: Environment-based configuration (DATABASE_URL, BETTER_AUTH_SECRET, CORS_ORIGINS)
‚úÖ **PASS**: Connection pooling configured for serverless consistency
‚úÖ **PASS**: Deterministic build process (requirements.txt with pinned versions)

### Modularity Principle

‚úÖ **PASS**: Backend is separate FastAPI application
‚úÖ **PASS**: Clear separation: routing (api/routes), auth (api/deps), models (models/), schemas (schemas/)
‚úÖ **PASS**: Spec-driven architecture follows feature specification

**Gate Decision**: ‚úÖ All constitution principles satisfied. Proceed to Phase 0 research.

## Project Structure

### Documentation (this feature)

```text
specs/001-todo-api-backend/
‚îú‚îÄ‚îÄ spec.md              # Feature specification
‚îú‚îÄ‚îÄ plan.md              # This file (/sp.plan output)
‚îú‚îÄ‚îÄ research.md          # Phase 0: Technology decisions
‚îú‚îÄ‚îÄ data-model.md        # Phase 1: Task entity design
‚îú‚îÄ‚îÄ quickstart.md        # Phase 1: Development setup
‚îú‚îÄ‚îÄ contracts/           # Phase 1: OpenAPI schema
‚îÇ   ‚îî‚îÄ‚îÄ todo-api.yaml
‚îú‚îÄ‚îÄ checklists/          # Quality validation
‚îÇ   ‚îî‚îÄ‚îÄ requirements.md
‚îî‚îÄ‚îÄ tasks.md             # Phase 2 (generated by /sp.tasks)
```

### Source Code (repository root)

```text
backend/                         # Existing FastAPI application
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ main.py                  # FastAPI application entry
‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config.py            # Environment configuration
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database.py          # Async database engine
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ security.py          # JWT verification (EXISTING)
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.py              # User model (EXISTING)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ todo.py              # Todo/Task model (EXISTS - needs review)
‚îÇ   ‚îú‚îÄ‚îÄ schemas/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.py              # JWT schemas (EXISTING)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ task.py              # Task request/response schemas (NEW)
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ deps.py              # Auth dependencies (EXISTING)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ tasks.py         # Task CRUD endpoints (NEW)
‚îÇ   ‚îî‚îÄ‚îÄ services/                # Business logic layer (NEW)
‚îÇ       ‚îî‚îÄ‚îÄ task_service.py
‚îú‚îÄ‚îÄ alembic/
‚îÇ   ‚îú‚îÄ‚îÄ versions/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ 002_rename_todos_to_tasks.py  # Migration (NEW)
‚îÇ   ‚îî‚îÄ‚îÄ env.py
‚îú‚îÄ‚îÄ tests/                       # Test suite (NEW)
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ conftest.py              # Pytest fixtures
‚îÇ   ‚îú‚îÄ‚îÄ test_auth.py             # JWT authentication tests
‚îÇ   ‚îú‚îÄ‚îÄ test_task_api.py         # API endpoint tests
‚îÇ   ‚îî‚îÄ‚îÄ test_task_isolation.py  # User isolation tests
‚îú‚îÄ‚îÄ requirements.txt             # Python dependencies
‚îú‚îÄ‚îÄ .env                         # Environment variables
‚îî‚îÄ‚îÄ README.md
```

**Structure Decision**: Leveraging existing backend/ FastAPI application with established authentication infrastructure. Will add task-specific routes, schemas, and services while reusing existing JWT verification, database configuration, and user models.

**Key Observations**:
- ‚úÖ Database models exist (models/todo.py) - may need field adjustments to match spec
- ‚úÖ JWT authentication infrastructure exists (core/security.py, api/deps.py)
- ‚úÖ Database connection configured (core/database.py with Neon pooling)
- üÜï Need to add: task routes, task schemas, task service layer, comprehensive tests

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

**Status**: ‚úÖ No violations - no complexity tracking required.

All constitution principles pass without exceptions.

## Phase 0: Research & Decisions

### Decision 1: API Route Structure

**Question**: Should we use `/api/{user_id}/tasks` pattern or flat `/api/tasks` with user_id from JWT only?

**Decision**: Use `/api/{user_id}/tasks` pattern as specified

**Rationale**:
- Specification explicitly requires this pattern (FR-008 through FR-013)
- Provides explicit verification that URL user_id matches JWT user_id (FR-003, FR-005)
- Clear audit trail in logs (user_id visible in path)
- Better alignment with frontend expectations

**Alternatives Considered**:
- Flat `/api/tasks` - Simpler but loses explicit path-based authorization check
- `/api/v1/{user_id}/tasks` - Adds versioning but not required in v1

**Implementation**: FastAPI routes will validate path parameter user_id against JWT-extracted user_id

---

### Decision 2: Database Table Naming

**Question**: Use `todos` (existing table) or rename to `tasks` (spec terminology)?

**Decision**: Rename database table from `todos` to `tasks`

**Rationale**:
- Specification consistently uses "task" terminology (Task entity, task endpoints)
- Code clarity: align database naming with API and business logic
- Migration overhead is minimal (single Alembic migration)

**Alternatives Considered**:
- Keep `todos` table name - Avoids migration but creates terminology inconsistency
- Use `tasks` in code but `todos` in DB - Confusing split terminology

**Implementation**: Create Alembic migration to rename `todos` table to `tasks`, update model class

---

### Decision 3: Response Schema Design

**Question**: Return full task object or minimal ID on POST/PUT operations?

**Decision**: Return full task object with all fields including timestamps

**Rationale**:
- Specification FR-009 requires "created task including id and timestamps"
- Frontend needs complete data to avoid additional GET request
- Standard REST practice for resource creation/updates

**Alternatives Considered**:
- Return only ID and status - Requires additional GET, poor UX
- Return partial object - Inconsistent, confusing to API consumers

**Implementation**: TaskResponse schema includes all fields: id, title, description, completed, owner_id, created_at, updated_at

---

### Decision 4: Completion Toggle Implementation

**Question**: Should PATCH /api/{user_id}/tasks/{id}/complete accept a boolean parameter or always toggle?

**Decision**: Always toggle (flip current state)

**Rationale**:
- Specification FR-013 says "toggle task completion status"
- Simpler API (no request body needed)
- Idempotent-like behavior (repeated calls alternate state)

**Alternatives Considered**:
- Accept boolean in request body - More explicit but violates "toggle" requirement
- Use PUT /tasks/{id}/status - Different pattern from spec

**Implementation**: PATCH endpoint takes no body, reads current state, flips boolean, saves

---

### Decision 5: Error Response Format

**Question**: What structure for error responses?

**Decision**: Use FastAPI's default HTTPException with `detail` field, optionally extend with `errors` array for validation

**Rationale**:
- Specification FR-024 requires "detail field for all error scenarios"
- FastAPI's built-in HTTPException provides consistent format
- Pydantic validation errors auto-format to 422 with field details

**Alternatives Considered**:
- Custom error schema - Unnecessary complexity
- RFC 7807 Problem Details - Overkill for simple API

**Implementation**: Raise HTTPException with detail string, Pydantic handles 422 validation errors

---

### Decision 6: Service Layer Pattern

**Question**: Implement business logic directly in route handlers or separate service layer?

**Decision**: Introduce lightweight service layer (task_service.py)

**Rationale**:
- Constitution Principle V (Modularity) requires clear separation
- Easier to test business logic independently of HTTP layer
- Better code organization for authorization checks

**Alternatives Considered**:
- Logic in route handlers - Violates modularity, hard to test
- Repository pattern - Too heavy for simple CRUD operations

**Implementation**: task_service.py contains validate_ownership, get_user_tasks, create_task, update_task, delete_task, toggle_completion

## Phase 1: Design Artifacts

### Data Model (see data-model.md)

**Task Entity**:
- `id`: Integer, primary key, auto-increment
- `title`: String(1000), required, non-empty
- `description`: String(5000), optional, nullable
- `completed`: Boolean, default=False
- `owner_id`: Integer, foreign key to users.id, required, indexed
- `created_at`: DateTime (UTC), auto-set on insert
- `updated_at`: DateTime (UTC), auto-update on modification

**Constraints**:
- Primary key on `id`
- Foreign key `owner_id` references `users.id` (no cascade delete)
- Index on `owner_id` for fast user-scoped queries
- Check constraint: `title` is not empty string

**Relationships**:
- Task belongs to one User (via owner_id)
- User has many Tasks (not enforced at DB level)

### API Contracts (see contracts/todo-api.yaml)

**Endpoints**:

1. **GET /api/{user_id}/tasks**
   - Summary: List all tasks for authenticated user
   - Auth: Required (JWT)
   - Path: user_id (integer)
   - Response 200: Array of TaskResponse
   - Response 401: Unauthorized
   - Response 403: Forbidden (user_id mismatch)

2. **POST /api/{user_id}/tasks**
   - Summary: Create new task
   - Auth: Required (JWT)
   - Path: user_id (integer)
   - Body: TaskCreate {title, description?}
   - Response 201: TaskResponse
   - Response 401: Unauthorized
   - Response 403: Forbidden
   - Response 422: Validation error

3. **GET /api/{user_id}/tasks/{id}**
   - Summary: Get single task by ID
   - Auth: Required (JWT)
   - Path: user_id (integer), id (integer)
   - Response 200: TaskResponse
   - Response 401: Unauthorized
   - Response 403: Forbidden
   - Response 404: Not Found

4. **PUT /api/{user_id}/tasks/{id}**
   - Summary: Update task title/description
   - Auth: Required (JWT)
   - Path: user_id (integer), id (integer)
   - Body: TaskUpdate {title?, description?}
   - Response 200: TaskResponse
   - Response 401: Unauthorized
   - Response 403: Forbidden
   - Response 404: Not Found
   - Response 422: Validation error

5. **DELETE /api/{user_id}/tasks/{id}**
   - Summary: Delete task
   - Auth: Required (JWT)
   - Path: user_id (integer), id (integer)
   - Response 204: No Content
   - Response 401: Unauthorized
   - Response 403: Forbidden
   - Response 404: Not Found

6. **PATCH /api/{user_id}/tasks/{id}/complete**
   - Summary: Toggle task completion status
   - Auth: Required (JWT)
   - Path: user_id (integer), id (integer)
   - Response 200: TaskResponse
   - Response 401: Unauthorized
   - Response 403: Forbidden
   - Response 404: Not Found

**Schemas**:

- **TaskCreate**: {title: string(required, 1-1000), description: string?(0-5000)}
- **TaskUpdate**: {title: string?(1-1000), description: string?(0-5000)}
- **TaskResponse**: {id: int, title: string, description: string|null, completed: bool, owner_id: int, created_at: datetime, updated_at: datetime}
- **ErrorResponse**: {detail: string, errors?: [{field: string, message: string}]}

### Quickstart (see quickstart.md)

**Prerequisites**:
- Python 3.12+
- PostgreSQL (Neon Serverless) connection string
- BETTER_AUTH_SECRET shared with frontend

**Setup Steps**:
1. Install dependencies: `pip install -r requirements.txt`
2. Configure .env: DATABASE_URL, BETTER_AUTH_SECRET, CORS_ORIGINS
3. Run migrations: `alembic upgrade head`
4. Start server: `uvicorn app.main:app --reload`
5. Access docs: `http://localhost:8000/docs`

**Testing**:
1. Install test deps: `pip install pytest pytest-asyncio httpx`
2. Run tests: `pytest`
3. Test with curl: `curl -H "Authorization: Bearer <token>" http://localhost:8000/api/1/tasks`

## Implementation Phases

### Phase 1: Database Schema Adjustments

**Objective**: Align existing `todos` table with specification requirements

**Tasks**:
1. Review existing `models/todo.py` against Task entity specification
2. Create Alembic migration to:
   - Rename table from `todos` to `tasks` (if using todos)
   - Ensure `title` has max length 1000
   - Ensure `description` is nullable with max length 5000
   - Verify `owner_id` index exists
   - Verify check constraint on non-empty title
3. Update SQLModel class name and tablename
4. Test migration on development database

**Acceptance**:
- Migration runs without errors
- `tasks` table exists with correct schema
- Foreign key to `users` table intact
- Indexes verified via EXPLAIN queries

---

### Phase 2: Request/Response Schemas

**Objective**: Define Pydantic models for API validation

**Tasks**:
1. Create `schemas/task.py` with:
   - TaskCreate (title, description)
   - TaskUpdate (title optional, description optional)
   - TaskResponse (all fields including timestamps)
2. Add field validators:
   - title: min_length=1, max_length=1000
   - description: max_length=5000
3. Configure schema examples for OpenAPI docs
4. Test schema validation with pytest

**Acceptance**:
- Schemas enforce spec constraints
- Empty title raises validation error
- Oversized strings rejected
- OpenAPI docs show clear examples

---

### Phase 3: Service Layer

**Objective**: Implement business logic with authorization checks

**Tasks**:
1. Create `services/task_service.py` with async functions:
   - `validate_ownership(task: Task, user_id: int)` - raises 403 if mismatch
   - `get_user_tasks(session, user_id: int) -> List[Task]`
   - `get_task_by_id(session, task_id: int, user_id: int) -> Task` - validates ownership
   - `create_task(session, data: TaskCreate, owner_id: int) -> Task`
   - `update_task(session, task_id: int, data: TaskUpdate, user_id: int) -> Task`
   - `delete_task(session, task_id: int, user_id: int) -> None`
   - `toggle_task_completion(session, task_id: int, user_id: int) -> Task`
2. Ensure all functions filter by owner_id
3. Raise HTTPException for 404/403 scenarios
4. Unit test each function

**Acceptance**:
- All functions enforce user ownership
- 403 raised when task.owner_id != user_id
- 404 raised for non-existent tasks
- Database queries use owner_id filter

---

### Phase 4: API Route Implementation

**Objective**: Implement 6 RESTful endpoints

**Tasks**:
1. Create `api/routes/tasks.py` with APIRouter
2. Implement endpoints:
   - GET /api/{user_id}/tasks
   - POST /api/{user_id}/tasks
   - GET /api/{user_id}/tasks/{id}
   - PUT /api/{user_id}/tasks/{id}
   - DELETE /api/{user_id}/tasks/{id}
   - PATCH /api/{user_id}/tasks/{id}/complete
3. Inject CurrentUser dependency (from api/deps.py)
4. Validate path user_id matches JWT user_id (raise 403 if not)
5. Call service layer functions
6. Return appropriate status codes and responses
7. Register router in app/main.py

**Acceptance**:
- All endpoints return correct status codes
- Path user_id validation works
- OpenAPI docs generate correctly
- Manual testing with httpx or curl succeeds

---

### Phase 5: Error Handling

**Objective**: Ensure consistent error responses across all scenarios

**Tasks**:
1. Review HTTPException usage in service layer
2. Add exception handlers in main.py if needed:
   - 500 Internal Server Error handler
   - Database connection error ‚Üí 503 Service Unavailable
3. Test error scenarios:
   - Missing JWT token ‚Üí 401
   - Invalid JWT token ‚Üí 401
   - Valid JWT but wrong user_id ‚Üí 403
   - Non-existent task ‚Üí 404
   - Invalid payload ‚Üí 422
4. Verify error response format matches {detail: string}

**Acceptance**:
- All error responses have `detail` field
- No stack traces exposed to clients
- Appropriate status codes returned

---

### Phase 6: Integration Testing

**Objective**: Validate end-to-end API behavior with database

**Tasks**:
1. Create `tests/conftest.py` with:
   - async test database session fixture
   - test user fixtures
   - JWT token generation helper
2. Create `tests/test_task_api.py`:
   - Test all CRUD operations
   - Test validation errors (empty title, etc.)
   - Test successful flows
3. Create `tests/test_task_isolation.py`:
   - Test cross-user access attempts (expect 403)
   - Test multiple users don't see each other's tasks
4. Create `tests/test_auth.py`:
   - Test missing/invalid JWT ‚Üí 401
   - Test expired JWT ‚Üí 401
5. Run full test suite with pytest

**Acceptance**:
- All tests pass
- Code coverage > 80%
- Multi-user isolation verified
- All error scenarios tested

---

### Phase 7: Documentation & OpenAPI

**Objective**: Generate comprehensive API documentation

**Tasks**:
1. Add docstrings to all route functions
2. Configure OpenAPI metadata in main.py:
   - Title: "Todo Full-Stack API"
   - Description from spec
   - Version: 1.0.0
3. Add response_model and status_code to all routes
4. Add OpenAPI tags for grouping ("Tasks")
5. Test /docs and /redoc endpoints
6. Export OpenAPI schema to contracts/todo-api.yaml

**Acceptance**:
- Swagger UI renders correctly
- All endpoints documented
- Request/response schemas visible
- Auth requirements shown

---

### Phase 8: Performance & Deployment Readiness

**Objective**: Verify performance and production configuration

**Tasks**:
1. Load test with locust or ab:
   - Verify <500ms p95 latency
   - Test 100+ concurrent requests
2. Review connection pooling settings:
   - pool_size=5, max_overflow=10 for serverless
3. Verify environment variable usage:
   - No hardcoded secrets
   - All config from .env
4. Add logging (structured JSON logs)
5. Update README with deployment instructions

**Acceptance**:
- Performance goals met
- No configuration hardcoded
- Logs structured for monitoring
- README complete

## Testing Strategy

### Unit Tests

**Scope**: Test service layer functions in isolation

**Fixtures**: Mock database session, mock Task objects

**Coverage**:
- validate_ownership function
- Each CRUD operation (create, read, update, delete, toggle)
- Edge cases (null description, max length strings)

### Integration Tests

**Scope**: Test API endpoints with real database

**Fixtures**: Test database, TestClient, JWT tokens for multiple users

**Coverage**:
- All 6 endpoints (success paths)
- User isolation (403 for cross-user access)
- Authentication failures (401)
- Validation errors (422)
- Not found errors (404)

### Manual Testing Checklist

- [ ] GET /api/{user_id}/tasks returns only user's tasks
- [ ] POST /api/{user_id}/tasks creates task and returns full object
- [ ] GET /api/{user_id}/tasks/{id} retrieves single task
- [ ] PUT /api/{user_id}/tasks/{id} updates task
- [ ] DELETE /api/{user_id}/tasks/{id} removes task (204)
- [ ] PATCH /api/{user_id}/tasks/{id}/complete toggles status
- [ ] Missing JWT ‚Üí 401
- [ ] Invalid JWT ‚Üí 401
- [ ] Valid JWT but wrong user_id ‚Üí 403
- [ ] Task not found ‚Üí 404
- [ ] Empty title ‚Üí 422
- [ ] Oversized title/description ‚Üí 422

## Risks & Mitigations

### Risk 1: Database Connection Failures

**Probability**: Medium (serverless cold starts)
**Impact**: High (API unavailable)

**Mitigation**:
- Connection pooling with pre-ping enabled
- Graceful error handling (return 503)
- Health check endpoint for monitoring

### Risk 2: JWT Secret Mismatch

**Probability**: Low (configuration error)
**Impact**: Critical (authentication broken)

**Mitigation**:
- Document secret sharing requirement clearly
- Add startup validation (verify secret is set)
- Test JWT verification in integration tests

### Risk 3: Performance Degradation

**Probability**: Medium (under load)
**Impact**: Medium (slow responses)

**Mitigation**:
- Database query optimization (indexes on owner_id)
- Connection pooling tuned for serverless
- Load testing before production deployment

### Risk 4: User Isolation Breach

**Probability**: Low (coding error)
**Impact**: Critical (data leakage)

**Mitigation**:
- Comprehensive isolation tests
- Service layer enforces ownership checks
- Code review focused on authorization logic

## Success Metrics

**Functional**:
- ‚úÖ All 6 endpoints operational
- ‚úÖ JWT authentication enforced on every request
- ‚úÖ User data isolation verified (no cross-user access)
- ‚úÖ Database persistence working

**Performance**:
- ‚úÖ p95 latency < 500ms
- ‚úÖ Support 100+ concurrent requests/second
- ‚úÖ Database queries optimized (indexed owner_id)

**Quality**:
- ‚úÖ Test coverage > 80%
- ‚úÖ All constitution checks pass
- ‚úÖ OpenAPI documentation complete
- ‚úÖ No hardcoded secrets

## Next Steps

1. ‚úÖ Complete Phase 0 research (this document)
2. ‚úÖ Generate Phase 1 artifacts (data-model.md, contracts/, quickstart.md)
3. ‚è≠Ô∏è Run `/sp.tasks` to generate tasks.md with detailed implementation tasks
4. ‚è≠Ô∏è Execute implementation via `/sp.implement`
5. ‚è≠Ô∏è Verify all functional requirements from spec.md
6. ‚è≠Ô∏è Run integration tests and validate user isolation
7. ‚è≠Ô∏è Deploy to staging environment for final validation
